mat_fliplr(m):= apply('matrix, maplist('reverse, args(m)));
mat_flipud(m):= apply('matrix, reverse(args(m)));

/* intput file */
define_variable(finput, "tif.txt", any);
tmp_input: "_tif.txt";

/* parameters of the simulation box */
%xmin%: 0;
%ymin%: 0;

%xmax%: 1;
%ymax%: 1;

/* the number of particlse */
define_variable(Ntotal, 4000, fixnum);
%Ntotal%: Ntotal;
kill(Ntotal);

/* domain volume */
Vdomain:  (%xmax% - %xmin%) * (%ymax% - %ymin%);

cmd: printf(false, "/usr/bin/awk -f gen-multi-resolution.awk ~a > ~a",
  finput, tmp_input);
system(cmd);

ml: apply('matrix, read_nested_list(tmp_input))$
%GS%: copymatrix(transpose(mat_flipud(ml)))$
%nx%: length(%GS%);
%ny%: length(first(%GS%));
%GS%: block([numer: true], (255 - %GS%)/255)$

/* volume of one cell */
%dx%     : (%xmax% - %xmin%)/%nx%;
%dy%     : (%ymax% - %ymin%)/%ny%;
%Vcell%  :  Vdomain / (%nx% * %ny%);

/* how much ink I need? */
ink: xreduce("+", flatten(args(%GS%))) * %Vcell%$
Rsph: rhs(solve('%Ntotal%*%pi*'R^2 = 'ink, 'R)[2]);
%ink_per_particle%: ink/%Ntotal%$

/*
['x1, 'x2, 'y1, 'y2, 'ink, 'level];
*/

/* get the ammount of ink in the rectangualr region (including both ends) */
getink(x1, x2, y1, y2):= block([s: 0],
  for i: x1 thru x2 do
  for j: y1 thru y2 do
  s: s + %GS%[i,j],
  s*%Vcell%);

/*

splite element in four partis
Usage:
lst: [1, nx, 1, ny, %Ntotal%, 0]$
spl: splite_element(lst)$
*/
splite_element(lst):=
block([x1: lst[1], x2: lst[2], y1: lst[3], y2: lst[4], Npart: lst[5], level: lst[6]],
  block([xc: round((x1+x2-1)/2), yc: round((y1+y2-1)/2), N1, N2, N3, N4, ink],
    ink: getink(x1, x2, y1, y2),
    N1:  round(Npart*getink(x1, xc, y1, yc)/ink),
    N2:  round(Npart*getink(xc+1, x2, y1, yc)/ink),
    N3:  round(Npart*getink(xc+1, x2, yc+1, y2)/ink),
    /* N4:  round(Npart*getink(x1,   xc, yc+1, y2)/ink), */
    N4:  Npart - N1 - N2 - N3,
    [
    [x1,   xc, y1,   yc,   N1, level+1],
    [xc+1, x2, y1,   yc,   N2, level+1],
    [xc+1, x2, yc+1, y2,   N3, level+1],
    [x1,   xc, yc+1, y2,   N4, level+1]
    ]));

%min_part_delta%: 0;
%max_level%     : 7;
splite_or_not(lst_in):=
block([lst: copy(lst_in)],
  block([Npart: lst[5], level: lst[6],
    listarith: true, numer: true],
    if level>=%max_level% or Npart<=4 then return(lst),
    nlist: splite_element(lst),
    print(maplist('fifth, nlist)),
    if every( lambda([q], abs(q[5] - Npart/4) <%min_part_delta%), nlist) then (print(maplist(fifth, nlist) - Npart/4),  lst)
    else maplist('splite_or_not, nlist)));

load("distrib")$
distrib_particles_aux(spl):=(if not listp(first(spl)) then 
  block([x1: spl[1], x2: spl[2], y1: spl[3], y2: spl[4], Npart: spl[5]],
    thru Npart do (
      x: random_continuous_uniform( %xmin% + %dx%*(x1-1), %xmin% + %dx%*x2),
      y: random_continuous_uniform( %ymin% + %dy%*(y1-1), %ymin% + %dy%*y2),
      plist: cons([x, y], plist)))
  else for el in spl do distrib_particles_aux(el), 'done)$
distrib_particles(spl):= block([plist: []],
  distrib_particles_aux(spl),
  plist);

lst: [1, %nx%, 1, %ny%, %Ntotal%, 0]$
spl: splite_or_not(lst)$
plist: distrib_particles(spl)$
write_data(plist, "p.dat");

rlist: 'draw2d(transparent=true);
distrib_corners(spl):=(if not listp(first(spl)) then 
  block([x1: spl[1], x2: spl[2], y1: spl[3], y2: spl[4]],
      rlist: endcons( rectangle([x1-1, y1-1], [x2, y2]), rlist))
  else for el in spl do distrib_corners(el), 'done)$
distrib_corners(spl);

plist: [];
distrib_particles2(spl):=(if not listp(first(spl)) then 
  block([x1: spl[1], x2: spl[2], y1: spl[3], y2: spl[4], Npart: spl[5], x, y],
    thru Npart do (
      x: random_continuous_uniform(x1-1, x2),
      y: random_continuous_uniform(y1-1, y2),
      plist: cons([x, y], plist)))
  else for el in spl do distrib_particles2(el), 'done)$
distrib_particles2(spl);

load("draw")$
pic: 'draw2d(palette = [3, 3, 3],
  image(ml, 0, 0, %nx%, %ny%),
  points(plist))$

plist: append(pic, rlist)$
ev(plist, draw2d)$
