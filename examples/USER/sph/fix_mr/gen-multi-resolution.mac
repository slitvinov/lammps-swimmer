mat_fliplr(m):= apply('matrix, maplist('reverse, args(m)));
mat_flipud(m):= apply('matrix, reverse(args(m)));

/* intput file */
define_variable(finput, "tif.txt", any);
tmp_input: "_tif.txt";

cmd: printf(false, "/usr/bin/awk -f gen-multi-resolution.awk ~a > ~a",
  finput, tmp_input);
system(cmd);

ml: apply('matrix, read_nested_list(tmp_input))$
%GS%: copymatrix(transpose(mat_flipud(ml)))$
%nx%: length(%GS%);
%ny%: length(first(%GS%));
%GS%: block([numer: true], (255 - %GS%)/255)$

/* max min */
mmx(i):=min(%nx%, max(1, i));
mmy(j):=min(%ny%, max(1, j));

/* small positive number used in ink calculations */
%eps%: 1e-20;

/* parameters of the simulation box */
%xmin%: 0;
%ymin%: 0;

%xmax%: 1;
%ymax%: %ymin% + (%xmax%-%xmin%)*%ny%/%nx%;

/* the number of particlse */
define_variable(Ntotal, 20000, fixnum);
%Ntotal%: Ntotal;

/* domain volume */
Vdomain:  (%xmax% - %xmin%) * (%ymax% - %ymin%);

/* volume of one cell */
%dx%     : (%xmax% - %xmin%)/%nx%$
%dy%     : (%ymax% - %ymin%)/%ny%$
%Vcell%  :  Vdomain / (%nx% * %ny%)$

/* how much ink I need? */
ink: xreduce("+", flatten(args(%GS%))) * %Vcell%$
Rsph: rhs(solve('%Ntotal%*%pi*'R^2 = 'ink, 'R)[2])$
%ink_per_particle%: ink/%Ntotal%$

/*
['x1, 'x2, 'y1, 'y2, 'ink, 'level];
*/

/* get the ammount of ink in the rectangualr region (including both ends) */
getink[x1, x2, y1, y2]:= block([s: 0, numer: true],
  mode_declare(s, flonum),
  for i: x1 thru x2 do
  for j: y1 thru y2 do
  s: s + %GS%[i,j],
  s*%Vcell%);

getvolume(x1, x2, y1, y2):= (x1-x2)*(y1-y2);

get_element_volume(lst):=
block([x1: lst[1], x2: lst[2], y1: lst[3], y2: lst[4]],
getvolume(x1, x2, y1, y2));

/*

splite element in four partis
Usage:
lst: [1, nx, 1, ny, %Ntotal%, 0]$
spl: splite_element(lst)$
*/
splite_element(lst):=
block([x1: lst[1], x2: lst[2], y1: lst[3], y2: lst[4],
  Npart: lst[5], level: lst[6], numer: true],
  block([xc: round((x1+x2-1)/2), yc: round((y1+y2-1)/2), N1, N2, N3, N4, ink],
    ink: getink[x1, x2, y1, y2],
    N1:  round(Npart*getink[x1, xc, y1, yc]/(ink+%eps%)),
    N2:  round(Npart*getink[xc+1, x2, y1, yc]/(ink+%eps%)),
    N3:  round(Npart*getink[xc+1, x2, yc+1, y2]/(ink+%eps%)),
    /* N4:  round(Npart*getink(x1,   xc, yc+1, y2)/ink), */
    N4:  Npart - N1 - N2 - N3,
    [
    [x1,   xc, y1,   yc,   N1, level+1],
    [xc+1, x2, y1,   yc,   N2, level+1],
    [xc+1, x2, yc+1, y2,   N3, level+1],
    [x1,   xc, yc+1, y2,   N4, level+1]
    ]));

stop_by_ink(lst):= every( lambda([q], q<1), splite_by_ink(lst));

%min_part_delta%: 1/10;
/* %max_level%     : min(8, floor(log(%nx%)/log(2))); */
%max_level%        : 9;
is_even(q, V):= is( abs(q[5] - Npart*get_element_volume(q)/V) <%min_part_delta%);
splite_or_not(lst_in):=
block([lst: copy(lst_in)],
  block([x1: lst[1], x2: lst[2], y1: lst[3], y2: lst[4],
    Npart: lst[5], level: lst[6], V,
    listarith: true, numer: true],
    if Npart<1                                   then return(lst),
    if getink[x1, x2, y1, y2]<%ink_per_particle% then return(lst),
    if level>=%max_level%                        then return(lst),
    nlist: splite_element(lst),
    V: get_element_volume(lst),
    if every(lambda([q], is_even(q, V)), nlist) then
    lst
    else maplist('splite_or_not, nlist)))$

load("distrib")$
lst: [1, %nx%, 1, %ny%, %Ntotal%, 0]$
spl: splite_or_not(lst)$

rlist: 'draw2d(transparent=true);
distrib_corners(spl):=(if not listp(first(spl)) then 
  block([x1: spl[1], x2: spl[2], y1: spl[3], y2: spl[4]],
      rlist: endcons( rectangle([x1-1, y1-1], [x2, y2]), rlist))
  else for el in spl do distrib_corners(el), 'done)$
distrib_corners(spl);

distrib_processing(spl):= block([rlist: []],
  distrib_processing_aux(spl),
  rlist);
distrib_processing_aux(spl):=(if not listp(first(spl)) then 
  block([x1: spl[1], x2: spl[2], y1: spl[3], y2: spl[4]],
      rlist: endcons( rectangle([x1-1, y1-1], [x2, y2]), rlist))
  else for el in spl do distrib_corners(el), 'done)$

distrib_particles(spl):=(if not listp(first(spl)) then 
  block([x1: spl[1], x2: spl[2], y1: spl[3], y2: spl[4], Npart: spl[5], x, y, nattempts, MAX_NATTEMPTS: 100],
    thru Npart do (
      nattempts: 0,
      do (
        x: random_continuous_uniform(x1-1/2, x2+1/2),
        y: random_continuous_uniform(y1-1/2, y2+1/2),
/*        x: (x1+x2)/2,
        y: (y1+y2)/2, */
        nattempts: nattempts + 1,
        if %GS%[mmx(round(x)),mmy(round(y))]>0 or nattempts>MAX_NATTEMPTS then return()
        ),
      plist: cons([x, y], plist)))
  else for el in spl do distrib_particles(el), 'done)$
plist: [];
distrib_particles(spl)$
plist_lammps: maplist( lambda([l], float([%xmin% + %dx%*first(l), %ymin% + %dy%*second(l)])), plist)$
write_data(plist_lammps, "p.dat");

is_inside(x, y, spl):= block([x1: spl[1], x2: spl[2], y1: spl[3],
  y2: spl[4], Npart: spl[5], lvl: spl[6]],
  if x>=x1 and x<=x2 and y>=y1 and y<=y2 then lvl else false);

find_level(x, y, spl):= block([lvl],
  catch(
    if not listp(first(spl)) then throw(is_inside(x, y, spl))
    else for el in spl do if (lvl: find_level(x, y, el))#false then throw(lvl),
    false));

compile(find_level, is_inside);

/*
with_stdout("lvl.dat",
  for iy thru %ny% do
  for ix thru %nx% do
  printf(true, "~d ~d ~d~%", ix-1, iy-1, find_level(ix, iy, spl)));
*/
  

/*
load("draw")$
pic: 'draw2d(palette = [3, 3, 3],
  image(ml, 0, 0, %nx%, %ny%),
  points(plist))$

plist: append(pic, rlist)$
ev(plist, draw2d)$

*/